
Le problÃ¨me vient probablement du curseur (cursor.last_create_at), qui ne se met pas Ã  jour correctement. Actuellement, ta configuration stocke le dernier createdAt rÃ©cupÃ©rÃ©, mais si lâ€™API de SentinelOne ne trie pas bien les donnÃ©es ou si lâ€™indexation dans Filebeat ne suit pas, tu risques de toujours rÃ©cupÃ©rer les mÃªmes Ã©vÃ©nements.

Correction du problÃ¨me

âœ… 1. VÃ©rifier que createdAt est bien mis Ã  jour

Dans ta configuration actuelle :

cursor:
  last_create_at:
    value: '[[.last_event.createdAt]]'

	â€¢	Si last_create_at ne se met pas Ã  jour correctement, alors Filebeat continue de rÃ©cupÃ©rer les mÃªmes logs.
	â€¢	VÃ©rifie dans Kibana/OpenSearch si createdAt des logs change bien entre chaque rÃ©cupÃ©ration.

âœ… 2. Modifier la gestion du curseur pour Ã©viter les doublons

Remplace cette partie :

- set:
    target: url.params.createdAt__gte
    value: '[[formatDate (parseDate .cursor.last_create_at)]]'
    default: '[[formatDate (now (parseDuration "-24h"))]]'

Par cette version corrigÃ©e :

- set:
    target: url.params.createdAt__gt
    value: '[[if .cursor.last_create_at]][[formatDate (parseDate .cursor.last_create_at)]]][[else]][[formatDate (now (parseDuration "-24h"))]][[end]]'

ðŸ“Œ Explication des changements :
	â€¢	Utilisation de createdAt__gt au lieu de createdAt__gte :
	â€¢	gte (â€œgreater than or equalâ€) inclut les logs ayant exactement la mÃªme valeur de createdAt, ce qui peut provoquer des doublons.
	â€¢	gt (â€œgreater thanâ€) garantit quâ€™on rÃ©cupÃ¨re uniquement les nouvelles entrÃ©es.
	â€¢	Ajout dâ€™une condition pour le curseur (if .cursor.last_create_at) :
	â€¢	Si le curseur est dÃ©fini, il utilise la derniÃ¨re valeur de createdAt.
	â€¢	Sinon, il rÃ©cupÃ¨re les logs des derniÃ¨res 24 heures (-24h).

âœ… 3. VÃ©rifier que createdAt est bien au bon format

Si SentinelOne renvoie un timestamp avec un fuseau horaire (Z pour UTC ou +00:00), il faut sâ€™assurer que Filebeat lâ€™interprÃ¨te bien.
Dans Kibana/OpenSearch, exÃ©cute une requÃªte :

GET sentinel_one-activity-*/_search
{
  "size": 5,
  "_source": ["createdAt"]
}

Si createdAt est bien en UTC et correspond aux logs envoyÃ©s, câ€™est bon. Sinon, il faut peut-Ãªtre normaliser la date.

âœ… 4. Tester avec des logs en direct

Lance Filebeat en mode debug pour voir si createdAt Ã©volue :

filebeat -e -d "httpjson"

	â€¢	VÃ©rifie les valeurs de createdAt rÃ©cupÃ©rÃ©es.
	â€¢	VÃ©rifie la valeur du curseur (cursor.last_create_at).
	â€¢	VÃ©rifie si Filebeat envoie toujours les mÃªmes logs.

ðŸš€ En RÃ©sumÃ© :
	1.	Passer de createdAt__gte Ã  createdAt__gt pour Ã©viter de rÃ©cupÃ©rer les mÃªmes logs.
	2.	Sâ€™assurer que le curseur cursor.last_create_at se met bien Ã  jour en regardant les logs Filebeat.
	3.	Lancer Filebeat en mode debug (-d "httpjson") pour voir ce qui est rÃ©ellement envoyÃ©.

Essaie cette correction et dis-moi si le problÃ¨me persiste !



filter {
  csv {
    separator => ","
    columns => ["NomServeur", "HÃ´teLocal", "PortLocal", "HÃ´teDistantIP", "NomHÃ´teDistant", "PortDistant", "Direction", "Application", "Action"]
  }

  # Nettoyage et transformation des champs
  mutate {
    gsub => [
      "HÃ´teLocal", "IP de l'hÃ´te local: ", "",
      "PortLocal", "Port local: ", "",
      "HÃ´teDistantIP", "Adresse IP de l'hÃ´te distant: ", "",
      "NomHÃ´teDistant", "Nom de l'hÃ´te distant: ", "",
      "PortDistant", "Port distant: ", "",
      "Application", "Application: ", "",
      "Action", "Action: ", ""
    ]
    strip => ["HÃ´teLocal", "PortLocal", "HÃ´teDistantIP", "NomHÃ´teDistant", "PortDistant", "Application", "Action"]
  }
}
gsub => [
    "local_host_ip", "IP de lâ€™hÃ´te local\s*:\s*", "",
    "local_port", "Port local\s*:\s*", "",
    "remote_host_ip", "Adresse IP de lâ€™hÃ´te distant\s*:\s*", "",
    "remote_host_name", "Nom de lâ€™hÃ´te distant\s*:\s*", "",
    "remote_port", "Port distant\s*:\s*", "",
    "application_name", "Application\s*:\s*", "",
    "action", "Action\s*:\s*", ""
]
mutate {
    gsub => [
        "local_host_ip", "^[^:]+:\s*", "",
        "local_port", "^[^:]+:\s*", "",
        "remote_host_ip", "^[^:]+:\s*", "",
        "remote_host_name", "^[^:]+:\s*", "",
        "remote_port", "^[^:]+:\s*", "",
        "application_name", "^[^:]+:\s*", "",
        "action", "^[^:]+:\s*", ""
    ]
}


