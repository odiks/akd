require 'json'

# Simule un événement Logstash sous forme de hash
event = {
  "AttachmentDetails" => {
    "test.txt" => {
      "AMP" => {
        "Verdict" => "FILE UNKNOWN",
        "fileHash" => "7f843d263304fb0516d6210e9de4fa7f01f2f623074aab6e3ee7051f7b785cfa"
      },
      "BodyScanner" => {
        "fsize" => 1024
      }
    },
    "example.doc" => {
      "AMP" => {
        "Verdict" => "MALICIOUS",
        "fileHash" => "abcd1234"
      }
    }
  }
}

# Simulation du traitement Logstash Ruby
if event["AttachmentDetails"].is_a?(Hash)
  file_names = []   # Tableau pour stocker les noms de fichiers
  file_hashes = []  # Tableau pour stocker les hashes des fichiers
  verdicts = []     # Tableau pour stocker les verdicts
  file_sizes = []   # Tableau pour stocker les tailles des fichiers

  event["AttachmentDetails"].each do |file_name, file_details|
    file_names << file_name  # Ajouter le nom du fichier au tableau

    # Vérifier si AMP existe et récupérer les informations
    if file_details["AMP"]
      file_hashes << file_details["AMP"]["fileHash"]
      verdicts << file_details["AMP"]["Verdict"]
    else
      file_hashes << nil  # Ajouter une valeur vide si AMP n'existe pas
      verdicts << nil
    end

    # Vérifier si BodyScanner existe et récupérer la taille du fichier
    if file_details["BodyScanner"]
      file_sizes << file_details["BodyScanner"]["fsize"]
    else
      file_sizes << nil  # Ajouter une valeur vide si pas de fsize
    end
  end

  # Ajouter les tableaux dans l'événement Logstash simulé
  event["file_names"] = file_names
  event["file_hashes"] = file_hashes
  event["verdicts"] = verdicts
  event["file_sizes"] = file_sizes

  # Optionnel : Supprimer le champ original AttachmentDetails
  event.delete("AttachmentDetails")
end

# Afficher le résultat sous forme de JSON
puts JSON.pretty_generate(event)



filter {
    ruby {
        code => '
            # Vérifier si AttachmentDetails est un hash (JSON)
            if event.get("AttachmentDetails").is_a?(Hash)
                index = 1  # Compteur pour numéroter les fichiers

                event.get("AttachmentDetails").each do |file_name, file_details|
                    # Stocker le nom du fichier sous un champ normalisé
                    event.set("file_name_#{index}", file_name)

                    # Extraire AMP details
                    if file_details["AMP"]
                        event.set("fileHash_#{index}", file_details["AMP"]["fileHash"])
                        event.set("Verdict_#{index}", file_details["AMP"]["Verdict"])
                    end

                    # Extraire BodyScanner details (ex: taille du fichier)
                    if file_details["BodyScanner"]
                        event.set("fsize_#{index}", file_details["BodyScanner"]["fsize"])
                    end

                    index += 1
                end

                # Supprimer le champ original AttachmentDetails (optionnel)
                event.remove("AttachmentDetails")
            end
        '
    }
}



avec tabb
filter {
    ruby {
        code => '
            # Vérifier si AttachmentDetails est un hash (JSON)
            if event.get("AttachmentDetails").is_a?(Hash)
                file_names = []   # Tableau pour stocker les noms de fichiers
                file_hashes = []  # Tableau pour stocker les hashes des fichiers
                verdicts = []     # Tableau pour stocker les verdicts
                file_sizes = []   # Tableau pour stocker les tailles des fichiers

                event.get("AttachmentDetails").each do |file_name, file_details|
                    file_names << file_name  # Ajouter le nom du fichier au tableau

                    # Vérifier si AMP existe et récupérer les informations
                    if file_details["AMP"]
                        file_hashes << file_details["AMP"]["fileHash"]
                        verdicts << file_details["AMP"]["Verdict"]
                    else
                        file_hashes << nil  # Ajouter une valeur vide si AMP n'existe pas
                        verdicts << nil
                    end

                    # Vérifier si BodyScanner existe et récupérer la taille du fichier
                    if file_details["BodyScanner"]
                        file_sizes << file_details["BodyScanner"]["fsize"]
                    else
                        file_sizes << nil  # Ajouter une valeur vide si pas de fsize
                    end
                end

                # Ajouter les tableaux dans l'événement Logstash
                event.set("file_names", file_names)
                event.set("file_hashes", file_hashes)
                event.set("verdicts", verdicts)
                event.set("file_sizes", file_sizes)

                # Optionnel : Supprimer le champ original AttachmentDetails
                event.remove("AttachmentDetails")
            end
        '
    }
}





ruby {
    code => '
        new_event = {}
        event.to_hash.each do |k, v|
            new_key = k.gsub(/^ESA/, "")  # Supprime le préfixe "ESA"
            new_event[new_key] = v
        end
        event.replace(new_event)
    '
}

filter {
    grok {
        match => {
            "[cisco_secure_email_gateway][log][message]" => 
            "^(?:%{DATA:_tmp.timestamp} )?CEF:%{NUMBER:[cisco_secure_email_gateway][log][cef_format_version]}\|
            %{WORD:[cisco_secure_email_gateway][log][appliance][vendor]}\|
            %{DATA:[cisco_secure_email_gateway][log][appliance][product]}\|
            %{DATA:[cisco_secure_email_gateway][log][appliance][version]}\|
            %{DATA:[cisco_secure_email_gateway][log][event_class_id]}\|
            %{DATA:[cisco_secure_email_gateway][log][event][name]}\|
            %{WORD:[event][severity]}\|
            %{GREEDYDATA:[_tmp][details]}$"
        }
    }
}



filter {
    # Vérifier si le champ `ESAAttachmentDetails` existe
    if [ESAAttachmentDetails] {
        
        # Initialiser un compteur pour générer des clés uniformes
        ruby {
            code => '
                # Initialiser un hash vide pour contenir les nouveaux champs
                new_fields = {}
                index = 1  # Initialiser un compteur pour générer des clés uniformes

                # Parcourir chaque fichier dans ESAAttachmentDetails
                event.get("ESAAttachmentDetails").each do |file_name, file_details|
                    # Si AMP et BodyScanner existent, les ajouter en top-level avec des noms de champs uniformes
                    if file_details["AMP"]
                        new_fields["fileHash_#{index}"] = file_details["AMP"]["fileHash"]
                        new_fields["Verdict_#{index}"] = file_details["AMP"]["Verdict"]
                    end
                    if file_details["BodyScanner"]
                        new_fields["fsize_#{index}"] = file_details["BodyScanner"]["fsize"]
                    end
                    # Incrémenter l'index pour le prochain fichier
                    index += 1
                end

                # Ajouter ces nouveaux champs dans l'événement
                event.set("attachment_details", new_fields)
            '
        }

        # Optionnel : vous pouvez supprimer l'ancien champ `ESAAttachmentDetails`
        mutate {
            remove_field => ["ESAAttachmentDetails"]
        }
    }
}
